<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"www.leechain.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":true,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="Java核心技术–卷I终于看完这本书了，看的中文版，文字读起来有些别扭，不过结合看过的毕老师的JavaSE视频，也是有所收获。 每章小结">
<meta property="og:type" content="article">
<meta property="og:title" content="Java核心技术--卷I">
<meta property="og:url" content="http://www.leechain.top/2016/06/22/book-javahxjs1/index.html">
<meta property="og:site_name" content="Qwerty Everyday.">
<meta property="og:description" content="Java核心技术–卷I终于看完这本书了，看的中文版，文字读起来有些别扭，不过结合看过的毕老师的JavaSE视频，也是有所收获。 每章小结">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2016-06-21T16:00:00.000Z">
<meta property="article:modified_time" content="2017-07-20T05:44:41.000Z">
<meta property="article:author" content="码农小钱">
<meta property="article:tag" content="阅读">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://www.leechain.top/2016/06/22/book-javahxjs1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java核心技术--卷I | Qwerty Everyday.</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Qwerty Everyday.</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">/* hello world */</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://www.leechain.top/2016/06/22/book-javahxjs1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/custom-avatar.jpg">
      <meta itemprop="name" content="码农小钱">
      <meta itemprop="description" content="// todo sth.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Qwerty Everyday.">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java核心技术--卷I
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2016-06-22 00:00:00" itemprop="dateCreated datePublished" datetime="2016-06-22T00:00:00+08:00">2016-06-22</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java核心技术–卷I"><a href="#Java核心技术–卷I" class="headerlink" title="Java核心技术–卷I"></a>Java核心技术–卷I</h2><p>终于看完这本书了，看的中文版，文字读起来有些别扭，不过结合看过的毕老师的JavaSE视频，也是有所收获。</p>
<h2 id="每章小结"><a href="#每章小结" class="headerlink" title="每章小结"></a>每章小结</h2><h3 id="第一章-Java程度设计概述"><a href="#第一章-Java程度设计概述" class="headerlink" title="第一章 Java程度设计概述"></a>第一章 Java程度设计概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.1 Java程序设计平台</span><br><span class="line">1.2 Java&quot;白皮书&quot;的关键术语</span><br><span class="line">简单性，面对对象，网络技能，健壮性，安全性，体系结构中立，可移植性，解释型，高性能，多线程，动态性</span><br><span class="line">1.3 Java Applet 与 Internet</span><br><span class="line">1.4 Java发展简史</span><br><span class="line">1.5 关于Java的常见误解</span><br></pre></td></tr></table></figure>

<h3 id="第二章-Java程序设计环境"><a href="#第二章-Java程序设计环境" class="headerlink" title="第二章 Java程序设计环境"></a>第二章 Java程序设计环境</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">2.1 安装Java开发工具箱</span><br><span class="line">2.2 选择开发环境</span><br><span class="line">2.3 使用命令行工具</span><br><span class="line">2.4 使用集成开发环境(IDE)</span><br><span class="line">2.5 运行图形化应用程序</span><br><span class="line">2.6 建立并运行Applet</span><br></pre></td></tr></table></figure>

<h3 id="第三章-Java的基本程序设计结构"><a href="#第三章-Java的基本程序设计结构" class="headerlink" title="第三章 Java的基本程序设计结构"></a>第三章 Java的基本程序设计结构</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">3.1 一个简单的Java应用程序</span><br><span class="line">3.2 注释</span><br><span class="line">3.3 数据类型</span><br><span class="line">整形，浮点类型，char类型，boolean类型</span><br><span class="line">3.4 变量</span><br><span class="line">变量的初始化，常量</span><br><span class="line">3.5 运算符</span><br><span class="line">自增运算符与自减运算符，关系运算符与boolean运算符，位运算符，数学函数与常量，数值类型之间的转换，强制类型转换，括号与运算符级别，枚举类型</span><br><span class="line">3.6 字符串</span><br><span class="line">子串，拼接，不可变字符串，检测字符串是否相等，空串与Null串，代码点与代码单元，字符串API，阅读联机API文档，构建字符串</span><br><span class="line">3.7 输入输出</span><br><span class="line">读取输入，格式化输出，文件输入与输出</span><br><span class="line">3.8 控制流程</span><br><span class="line">块作用域，条件语句，循环，确定循环，多重选择:switch语句，中断控制流程语句(continue,break)</span><br><span class="line">3.9 大数值</span><br><span class="line">3.10 数组</span><br><span class="line">foreach 循环，数组初始化以及匿名数组，数组拷贝，命令行参数，数组排序，多维数组，不规则数组</span><br></pre></td></tr></table></figure>

<h3 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">4.1 面对对象程序设计概述(OOP)</span><br><span class="line">类（Class），对象（Object，行为behavior，状态state，标识identity），识别类，类之间的关系(依赖uses-a，聚合has-a，继承is-a)</span><br><span class="line">构造（Construct），实例（Instance），封装（Encapsulation，数据隐藏，黑盒），实例域（instance field），方法（method），状态（state），继承（Inheritance）</span><br><span class="line">Algorithms+Data Structures&#x3D;Programs</span><br><span class="line">面向过程，算法第一位，数据结构第二位</span><br><span class="line">面向对象，数据第一位，算法第二位</span><br><span class="line">4.2 使用预定义类</span><br><span class="line">对象与对象变量，更改器方法与访问类方法</span><br><span class="line">4.3 用户自定义类</span><br><span class="line">多个源文件的使用，从构造器开始，隐式参数与显式参数，封装的优点(getXXX,setXXX，数据private)，基于类的访问权限，私有方法，final实域类</span><br><span class="line">4.4 静态域与静态方法(static)</span><br><span class="line">静态域，静态常量，静态方法，工厂方法，main方法</span><br><span class="line">4.5 方法参数</span><br><span class="line">Java目前只有值传递，没有C语言内的地址传递。Java引用居多。</span><br><span class="line">4.6 对象构造</span><br><span class="line">重载(重载解析，overloading resolution)，默认域初始化(尽量显式赋初值)，无参数的构造器，显示域初始化，参数化（this），调用另一个构造器，初始化块(initialization block)，对象析构与finalize方法</span><br><span class="line">4.7 包</span><br><span class="line">类的导入(import)，静态导入(静态方法，静态域)，将类放入包中，包的作用域</span><br><span class="line">4.8 类路径</span><br><span class="line">4.9 文档注释（javadoc）</span><br><span class="line">注释的插入，类注释，方法注释，域注释，通用注释，包与概述注释，注释的抽取</span><br><span class="line">4.10 类设计技巧</span><br><span class="line">保障数据私有(private)，显式的数据初始化，类内数据需要认真设计，类间关系想想清楚，类内关联降低，不是所有的类都需要set和get，类的分解恰当，类和方法名要与实际对应。</span><br></pre></td></tr></table></figure>

<h3 id="第五章-继承"><a href="#第五章-继承" class="headerlink" title="第五章 继承"></a>第五章 继承</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">5.1 类、超类（superclass,baseclass,parentclass）和子类(subclass,derivedclass,childclass)</span><br><span class="line">继承（Inheritance，复用,拓展,覆盖override）层次（inheritance hierarchy），多态（子类对象赋给超类变量，但不能将超类的引用赋给子类变量），动态绑定，阻止继承：final类和方法，强制类型转换（instanceof检测），抽象类（abstract），受保护访问（private,protected,public,default）</span><br><span class="line">super和this，Java不支持多继承</span><br><span class="line">5.2 Object：所有类的超类</span><br><span class="line">equals方法，相等测试与继承，hashCode方法，toString方法</span><br><span class="line">5.3 泛型数组列表</span><br><span class="line">访问数组列表元素（ArrayList&lt;Object&gt;），类型化与原始数组列表的兼容性，对象包装器与自动装箱(autoboxing)</span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">5.4 参数数量可变的方法(范例printf)</span><br><span class="line">5.6 枚举类(Enum)</span><br><span class="line">5.7 反射（reflection，强大工具）</span><br><span class="line">Class类，捕获异常(try..catch)，利用反射分析类的能力(Field,Method,Constructor；private,protected,public,default)，在运行时使用反射分析对象，使用反射编写泛型数组代码，调用任意方法（对比接口interface和内部类，不建议使用Method对象，效率相对较低而且不易维护）</span><br><span class="line">5.8 继承设计的技巧</span><br><span class="line">将公共操作和域放在超类；</span><br><span class="line">不要使用受保护的域，确保封装性private；</span><br><span class="line">使用继承实现“is-a”关系；</span><br><span class="line">除非所有继承的方法都有意义，否则不要使用继承；</span><br><span class="line">在覆盖方法时，不要改变预期的行为；</span><br><span class="line">使用多态、接口，而非类型信息；</span><br><span class="line">不要过多的使用反射，反射多用于工具类。</span><br></pre></td></tr></table></figure>

<h3 id="第六章-接口与内部类"><a href="#第六章-接口与内部类" class="headerlink" title="第六章 接口与内部类"></a>第六章 接口与内部类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">6.1 接口（interface）</span><br><span class="line">接口的特性</span><br><span class="line">接口可以白看作没有实例域的抽象类，但有区别。</span><br><span class="line">实现（implement）</span><br><span class="line">如果类遵从某个特定接口，那么就履行这项服务（必须实现接口内的方法）。</span><br><span class="line">任意的x,y，sgn(x.compareTo(y))&#x3D;&#x3D;-sgn(y.compareTo(x))</span><br><span class="line">接口不是类，不能用new运算符实例化一个接口，即构造接口的对象，但能声明接口的变量。</span><br><span class="line">接口变量必须引用实现了接口的类对象，使用instanceof可以检查对象是否实现了某个特定的接口。</span><br><span class="line">像类可以继承一样，接口也可以被扩展。</span><br><span class="line">接口不能有实例域或静态方法，但是可以包含常量。</span><br><span class="line">接口方法将被标记为public，域标记public static final。</span><br><span class="line">接口与抽象类</span><br><span class="line">Java不支持多继承（mulitiple inheritance，比较复杂而且容易造成效率降低），即只能有一个超类，但是可以实现多个接口。</span><br><span class="line">6.2 对象克隆</span><br><span class="line">拷贝与克隆，浅拷贝与深拷贝。Clonable实现的是深拷贝（约等于完全拷贝了一个独立的新对象）。</span><br><span class="line">6.3 接口与回调（callback）</span><br><span class="line">Java中函数指针的调用类似物--Method对象，但速度反而略慢，且麻烦，而且没有编译时的安全检查。</span><br><span class="line">回调典型如Timer。</span><br><span class="line">6.4 内部类（inner class）</span><br><span class="line">内部类是定义在另一个类中类。</span><br><span class="line">内部类可以访问该类包括私有域的数据。</span><br><span class="line">内部类可以相对同一个包而言可以隐藏起来。</span><br><span class="line">匿名内部类可以定义一个回调函数且不用编写大量的代码。</span><br><span class="line">6.4.1 使用内部类访问对象状态</span><br><span class="line">内部类与接口是Java重要的基本特性。</span><br><span class="line">内部类的对象总有一个隐式引用，指向了创建它的外部类对象，由编译器自动添加。</span><br><span class="line">内部类当且仅当外部类需要时才会有实例域。</span><br><span class="line">常规类具有包可见性或者公共可见性，而内部类可以是私有类。</span><br><span class="line">6.4.2 内部类的特殊语法规则</span><br><span class="line">内部类中，使用外部类的引用正规语法：OuterClass.this</span><br><span class="line">在外围类的作用域之外，可以这样的语法来引用内部类：OuterClass.InnerClass</span><br><span class="line">6.4.3 内部类是否安全，必要，有用</span><br><span class="line">编译器将内部类翻译成$来分割外部类名和内部类名的常规类文件，虚拟机对此一无所知。</span><br><span class="line">内部类不是绝对安全的。</span><br><span class="line">例：static boolean access$0(com.chain.chapter6.TalkingClock);</span><br><span class="line">编译器在外围类添加静态方法，返回作为参数传递给它的对象域。这个可以被调用用作访问类内私有域数据，但难度较高。</span><br><span class="line">6.4.4 局部内部类</span><br><span class="line">局部类对外界的世界完全隐藏起来，当然也不能用public或private。</span><br><span class="line">6.4.5 由外部方法访问final变量</span><br><span class="line">局部类不仅可以访问包含它们的外部类，也可以访问局部变量，但这些局部变量需要被声明为final。原理在于编译器会自动的为局部变量创建副本。</span><br><span class="line">例：final com.chain.chapter6.TalkingClock this$0;</span><br><span class="line">public com.chain.chapter6.TalkingClock$TimePrinter(com.chain.chapter6.TalkingClock);</span><br><span class="line">这是内部类自动生成的构造器，作为副本。</span><br><span class="line">6.4.6 匿名内部类（Annoymous inner class）</span><br><span class="line">例：Person psn1&#x3D;new Person(&quot;Tom&quot;);  &#x2F;&#x2F;这是Person类的一个实例</span><br><span class="line">Person psn2&#x3D;new Person(&quot;Jack&quot;)&#123; ... &#125;; &#x2F;&#x2F;an object of an inner class extending person</span><br><span class="line">其实匿名内部类与普通内部类可以相互转化，匿名内部类有时可以减少代码的编写，但其实不易维护。</span><br><span class="line">ArrayList&lt;String&gt; friends&#x3D;new ArrayList&lt;&gt;();</span><br><span class="line">friends.add(&quot;Andy&quot;);</span><br><span class="line">friends.add(&quot;Dan&quot;);</span><br><span class="line">invite(friends);</span><br><span class="line">&#x2F;&#x2F;接下来friends数组列表可以不要了</span><br><span class="line">&#x3D;&#x3D;&gt;</span><br><span class="line">invite(new ArrayList&lt;String&gt;&#123;&#123;add(&quot;Andy&quot;);add(&quot;Dan&quot;);&#125;&#125;);</span><br><span class="line">匿名类使用equals时需注意。</span><br><span class="line"></span><br><span class="line">new SuperType(construction parameters)&#123;</span><br><span class="line">inner class methods and data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">new InterfaceType()&#123;</span><br><span class="line">methods and data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">6.4.7 静态内部类</span><br><span class="line">仅需隐藏一个类在另一个类的内部时，并不需要内部类引用外部类对象时，可将内部类声明为static，以便取消编译器自动添加的外部类的引用。static class and method。</span><br><span class="line">6.5 代理（Proxy）</span><br><span class="line">动态加载类，invoke(Object proxy,Method method,Object[] args)</span><br></pre></td></tr></table></figure>

<h3 id="第七章到第九章-GUI部分"><a href="#第七章到第九章-GUI部分" class="headerlink" title="第七章到第九章 GUI部分"></a>第七章到第九章 GUI部分</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">省略</span><br></pre></td></tr></table></figure>

<h3 id="第十章-部署应用程序和applet"><a href="#第十章-部署应用程序和applet" class="headerlink" title="第十章 部署应用程序和applet"></a>第十章 部署应用程序和applet</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">10.1 JAR文件（Jav归档文件）</span><br><span class="line">将应用程序进行打包，可以包含类文件，图像和声音的资源文件。</span><br><span class="line">JAR文件是压缩的，使用了熟悉的ZIP压缩格式。</span><br><span class="line">使用JAVA自带的jar工具可以创建JAR文件。</span><br><span class="line">清单文件（MANIFEST.MF)</span><br><span class="line">可运行的jar文件</span><br><span class="line">10.2 Java WEb Start</span><br><span class="line">密封，沙箱，签名代码,JNLP API</span><br><span class="line">10.3 applet</span><br><span class="line">HTML标记语属性，object标记，使用参数向applet传递信息，访问图像和音频文件，applet上下文</span><br><span class="line">10.4 应用程序首选项存储</span><br><span class="line">属性映射（Properties类）</span><br><span class="line">Preferences API（数据以XML存储）</span><br></pre></td></tr></table></figure>

<h3 id="第十一章-异常、断言、日志和调试"><a href="#第十一章-异常、断言、日志和调试" class="headerlink" title="第十一章 异常、断言、日志和调试"></a>第十一章 异常、断言、日志和调试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line">11.1 处理错误</span><br><span class="line">出现错误而无法执行：返回安全状态，进行保存作业的操作，可以以适当的方式终止程序。</span><br><span class="line">用户输入错误（如输入不标准），设备错误（如设备脱机），物理限制（如磁盘满了），代码错误（如返回值处理）。Java中出现问题后会采用另一种路劲退出该方法，并抛出异常（throw），并停止继续执行，立即退出。异常处理机制（exception handler）会接着处理。</span><br><span class="line">异常分类</span><br><span class="line">Throwable:Error（无法控制的错误）+Exception（）</span><br><span class="line">Exception:IOException+RuntimeException（逻辑错误，checked）+非    RuntimeException（unchecked）</span><br><span class="line">声明已检查异常(throws)</span><br><span class="line">如何抛出异常</span><br><span class="line">throw new XXXException;</span><br><span class="line">throws XXXException</span><br><span class="line">创建异常类</span><br><span class="line">派生一个Exception类，超类为Throwable</span><br><span class="line">11.2 捕获异常(try&#x2F;catch&#x2F;finally)</span><br><span class="line">捕获多个异常</span><br><span class="line">多个catch语句，每一个catch语句内对应一个已知的错误类</span><br><span class="line">再次抛出异常与异常链</span><br><span class="line">try&#123;</span><br><span class="line">...</span><br><span class="line">&#125;catch(SQLException e)&#123;</span><br><span class="line">throw new ServletException(&quot;throw again&quot;+e.getMessage());</span><br><span class="line">&#125;</span><br><span class="line">finally字句</span><br><span class="line">当程序错误时，一般会无条件终止，这使得资源尚未释放，finally则无论发生还是没有发生错误都会执行，以便及时关闭资源。</span><br><span class="line">带资源的try语句</span><br><span class="line">open a res</span><br><span class="line">try&#123;</span><br><span class="line">try&#123;</span><br><span class="line">work with the res</span><br><span class="line">&#125;finally&#123;</span><br><span class="line">close the res</span><br><span class="line">&#125;</span><br><span class="line">&#125;catch(XXXException e)&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">分析堆栈跟踪元素(stack trace)</span><br><span class="line">方法调用过程的列表，包含程序执行过程中的方法调用的特定位置。</span><br><span class="line">printStackTace();</span><br><span class="line">11.3 使用异常机制的技巧</span><br><span class="line">尽量避免错误的发生，不能用作测试，滥用会降低效率；</span><br><span class="line">不要太过分的细化异常；</span><br><span class="line">抛出的异常如果重要，需要利用异常的层次结构；</span><br><span class="line">重要的异常需要去处理，而不是一直空着，捕获到却不处理；</span><br><span class="line">早抛出，晚捕获</span><br><span class="line">11.4 使用断言（assert）</span><br><span class="line">启用和禁用断言</span><br><span class="line">java -anableassertions XXXX</span><br><span class="line">使用断言完成参数检查</span><br><span class="line">Java语言中3种常见处理错误的机制：</span><br><span class="line">抛出一个异常，日志，使用断言</span><br><span class="line">使用断言时，断言失败是致命的，不可恢复的错误。断言检查用于开发和测试阶段。</span><br><span class="line">为文档假设使用断言</span><br><span class="line">assert i!&#x3D;null:i;</span><br><span class="line">11.5 记录日志</span><br><span class="line">最原始的记录方式就是println出觉得有错误的地方。但是建议使用记录日志(Logger)的API。</span><br><span class="line">可以方便的取消全部日志记录，打开关闭很方便。</span><br><span class="line">可以一键禁止日志，减少系统开销。</span><br><span class="line">日志记录可以设置不同的处理方式，如XML或文本。</span><br><span class="line">日志记录应该添加上如包名等具有层次结构的名字。</span><br><span class="line">基本日志</span><br><span class="line">高级日志</span><br><span class="line">修改日志管理器配置</span><br><span class="line">本地化</span><br><span class="line">处理器</span><br><span class="line">过滤器</span><br><span class="line">格式化器</span><br><span class="line">日志记录说明</span><br><span class="line">11.6 调试技巧</span><br><span class="line">System.out.println(&quot;x&#x3D;&quot;,x);</span><br><span class="line">日志代理，logging proxy</span><br><span class="line">Logger.getGlobal().info(&quot;x&#x3D;&quot;,x);</span><br><span class="line">每个类里可以放一个main()用于测试，事后可以注释，java只调用启动类的main()</span><br><span class="line">JUnit</span><br><span class="line">Throwable提供的printStackTrace()</span><br><span class="line">代码的任意位置插入这条语句就可以堆栈跟踪，Thread.dumpStack()</span><br><span class="line">可以将错误输出到文件中，比如printStackTrace(out)，或者命令行参数重定向输出</span><br><span class="line">将日常调试的信息写入log文件</span><br><span class="line">java -verbose 可以将类的加载信息输出</span><br><span class="line">javac -Xlint:fallthrough 可以通知编译器检查某个特别注意点</span><br><span class="line">jconsole监控管理虚拟机的内存消耗，线程使用，类加载情况</span><br><span class="line">jmap获得堆的转储，然后在localhost:7000</span><br><span class="line">如果使用-Xprof标志，则会剖析经常用到的方法。</span><br><span class="line">11.7 GUI程序排错技巧</span><br><span class="line">11.8 使用调试器</span><br><span class="line">使用Eclipse的Debug模式</span><br></pre></td></tr></table></figure>

<h3 id="第十二章-泛型程序设计"><a href="#第十二章-泛型程序设计" class="headerlink" title="第十二章 泛型程序设计"></a>第十二章 泛型程序设计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">在java5内加入，比强制使用类型转换的代码较安全，较C#而言，Java的泛型是“假泛型”。</span><br><span class="line">12.1 为什么要使用泛型程序设计</span><br><span class="line">在编译时提供安全检查，消除强制类型转换（隐式自动完成，运行时都是普通类，再从泛型容器里取出值时，编译器进行类型转换），最大限度重用代码。</span><br><span class="line">但是，擦除使得无法与数组混合使用的很好，基本类型（int,float等）无法作为类型参数，需要使用包装类（Integer等），不能用于显示引用运行时的类型操作中（如instanceof和new表达式），重载不识别泛型，基类劫持了接口，try&#x2F;catch语句不能捕获泛型类型的异常，泛型类不能使用Super，通配符不能盲目使用？等。</span><br><span class="line">12.2 定义简单泛型类</span><br><span class="line">类型变量T，用&lt;&gt;框住，放在类名后面。用具体的类型来替换。</span><br><span class="line">class Generic&lt;T&gt;&#123;&#125;</span><br><span class="line">12.3 泛型方法</span><br><span class="line">public static &lt;T&gt; T getMiddle(T...a)&#123;</span><br><span class="line">return a[a.length&#x2F;2];</span><br><span class="line">&#125;</span><br><span class="line">类型变量放在修饰符之后，返回类型之前</span><br><span class="line">12.4 类型变量的限定</span><br><span class="line">泛型需要绑定接口，比如int和Integer.</span><br><span class="line">public static &lt;T extends Comparable&gt; T minmax(T[] a)&#123;&#125;</span><br><span class="line">修饰符+类型变量+返回类型+方法名（参数...）</span><br><span class="line">T与绑定的类型可以是类也可以是接口，不过选择extends接近子类的概念。限定类型用&amp;隔开，而逗号用来分割类型变量</span><br><span class="line">12.5 泛型代码和虚拟机</span><br><span class="line">虚拟机没有泛型类型对象，所有对象都属于普通类。无论何种泛型，都有一种相应的原始类型（raw type），原始类型的名字就是删除类型参数后的泛型类型名，擦除（erased）类型变量T，并替换为限定类型（无限定类型就使用Object），T是一个无限定的变量，所以可以直接用Object替换，但是这有区别。</span><br><span class="line">翻译泛型表达式，擦除返回的是Object类型，编译器会自动插入强制类型转换。</span><br><span class="line">翻译泛型方法，类型擦除和多态可以用桥方法解决，即</span><br><span class="line">public void setSecond(Object second) &#123; setSecond( (Date) second); &#125;</span><br><span class="line">泛型转换的事实，虚拟机中没有泛型，只有普通类和方法；所有类型参数都用它们的限定类型替换；桥方法被合成来保持多态；为保持类型安全性，必要时插入强制类型转换。</span><br><span class="line">调用遗留代码，利用注释（annotation）@SuppreussWarnings(&quot;unchecked&quot;)，@SafeVarargs</span><br><span class="line">12.6 约束与局限性</span><br><span class="line">Java泛型的限制，大多由类型擦除引起的。</span><br><span class="line">不能用类型参数代替基本类型，例如XXX&lt;int&gt;，只用XXX&lt;Integer&gt;，保持Java一切皆对象思想，如果要使用可以使用包装类实现，比如Integer或者自己定义的类。</span><br><span class="line">不能使用Instanceof，所有泛型类运行时都是普通类而已，同样getClass()也是如此。</span><br><span class="line">不能创建参数化类型的数组，比如Pair&lt;String&gt; table&#x3D;new Pair&lt;&gt;[10]这样在擦除后。table类型是Pair[10]，而非Pair&lt;String&gt;[10]，如果需要收集参数化类型对象，可以使用ArrayList&lt;Pair&lt;String&gt;&gt;周转实现。或者：</span><br><span class="line">@SafeVarargs static &lt;T&gt; T[] array(T...array)&#123;return array;&#125;</span><br><span class="line">Pair&lt;String&gt;[] table &#x3D;array(pair1,pair2);</span><br><span class="line">Object[] objary&#x3D;table;</span><br><span class="line">bojary[0]&#x3D;new Pair&lt;Employee&gt;();  YES</span><br><span class="line">table[0]&#x3D;new Pair&lt;Employee&gt;();    ERR</span><br><span class="line">不能实例化类型变量，如new T(...)，new T[...]，T.class，因为T会被擦除成Object，可以使用以下实现：</span><br><span class="line">public static &lt;T&gt; Pair&lt;T&gt; makePair(Class&lt;T&gt; cl)&#123;</span><br><span class="line">try&#123;</span><br><span class="line">return new Pair&lt;&gt;(cl.newInstance(),cl.newInstance());</span><br><span class="line">&#125;catch( Exception e ) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">接下来：</span><br><span class="line">Pair&lt;String&gt; p&#x3D;ArrayAlg.makeClass(String.class);</span><br><span class="line">不能抛出或捕获泛型类的实例异常，</span><br><span class="line">注意擦除后的冲突</span><br><span class="line">泛型类型的继承规则，为了安全，其实泛型的继承互相没有联系</span><br><span class="line">12.8 通配符类型</span><br><span class="line">Pair&lt;? extends Employee&gt;</span><br><span class="line">? super Manager</span><br><span class="line">12.9 反射和泛型</span><br></pre></td></tr></table></figure>

<h3 id="第十三章-集合"><a href="#第十三章-集合" class="headerlink" title="第十三章 集合"></a>第十三章 集合</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line">见《数据结构与算法经典问题解析Java版》</span><br><span class="line">数据结构（Data Structures）</span><br><span class="line">JAVA最初：Vector、Stack、HashTable、BitSet、Enumeration</span><br><span class="line">现在：Collection, List,LinkedList,ArrayList,Vector,Stack,Set </span><br><span class="line">C++标准模板库STL复杂，结合泛型算法，Java的集合类库（Collection）</span><br><span class="line">接口interface、实现implementation在Java中分离</span><br><span class="line"></span><br><span class="line">队列（queue）,FIFO先进先出：</span><br><span class="line">循环数组，链表</span><br><span class="line">Queue接口实现</span><br><span class="line">ArrayQueue，LinkedList类</span><br><span class="line">一般循环数组比链表要高效，但是数组有界</span><br><span class="line">Java中还有一个AbstractQueue，抽象队列，可以自己实现扩展队列</span><br><span class="line"></span><br><span class="line">集合接口（Collection）和迭代器接口（Iteration）</span><br><span class="line">集合接口有两个基本的方法add，iterator</span><br><span class="line">Java的迭代器位于两个元素之间，当调用next时，会越过下一个元素，并返回刚刚越过的那个元素的引用。需要配合hasNext()。remove方法会删除上次next方法返回的元素。next与remove相互依赖。</span><br><span class="line">每次调用remove时需要在之前调用next</span><br><span class="line">Java中有一个AbstractCollenction，基础方size和iterator抽象化，泛型接口。</span><br><span class="line"></span><br><span class="line">Collection  </span><br><span class="line">├List  </span><br><span class="line">│├LinkedList  </span><br><span class="line">│├ArrayList  </span><br><span class="line">│└Vector  </span><br><span class="line">│　└Stack  </span><br><span class="line">└Set</span><br><span class="line">│   ├ TreeSet</span><br><span class="line">│   ├ EnumSet</span><br><span class="line">│   ├ HashSet</span><br><span class="line">│   ├ LinkedHashSet</span><br><span class="line">│</span><br><span class="line">└Queue</span><br><span class="line">   ├ArrayDeque</span><br><span class="line">   ├PriorityDeque</span><br><span class="line"></span><br><span class="line">Map  </span><br><span class="line">├Hashtable  </span><br><span class="line">├HashMap  </span><br><span class="line">├TreeMap</span><br><span class="line">├EnumMap</span><br><span class="line">├LinkedHashMap</span><br><span class="line">├IdentityHashMap    </span><br><span class="line">└WeakHashMap </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Set集,List链,Map（映射）表，Queue队列，Stack栈</span><br><span class="line">Linked链接,Array数组,Hash哈希、散列,Tree树</span><br><span class="line">Sorted,Unsorted</span><br><span class="line">Vector</span><br><span class="line"></span><br><span class="line">链表：LinkedList，List接口</span><br><span class="line">数组列表ArrayList类，删除插入一个元素代价较大</span><br><span class="line">链表LinkedList类，删除插入方便</span><br><span class="line">Java中，链表是双向的（doubly linked）</span><br><span class="line">C语言指针，Java则是引用</span><br><span class="line">链表是有序集合（Ordered Collection）</span><br><span class="line">add方法依赖迭代器</span><br><span class="line">set是无序的</span><br><span class="line">Java屏蔽了双向链表复杂的引用变更，add，remove,next,hasNext，很好的屏蔽了细节。</span><br><span class="line">如果同时有两个迭代器最链表进行修改操作，将会抛出ConcurrentModificationException</span><br><span class="line">但是一个只读，另一个可读可写的两个迭代器是允许的</span><br><span class="line">链表不支持随机读取，所以get(i)方法不适合用来遍历链表</span><br><span class="line">如果数组中元素较少，可以完全使用ArrayList，可以实现随机访问</span><br><span class="line"></span><br><span class="line">数组列表：ArrayList，List接口</span><br><span class="line">封装了一个可动态再分配的对象数组</span><br><span class="line">Vector类所有方法是同步的，可由多个线程来访问Vector，进行同步操作</span><br><span class="line">但是，单线程使用Vector就得不偿失了</span><br><span class="line">ArrayList是非同步的。</span><br><span class="line"></span><br><span class="line">散列表：HashTable，散列值：HashCode，Set接口，HashSet</span><br><span class="line">链表和数组都是有一定顺序的，查找元素需要具体的位置或者从头遍历等方法，速度较慢</span><br><span class="line">HashTable可以快速的找到元素，如果不在意数据的排列的话，数据是无序的</span><br><span class="line">Java中，散列表是有链表数组产生的，每个列表被称为桶（bucket）</span><br><span class="line">确定位置，先计算散列值，在与桶的总数取余，这个值就是桶的索引</span><br><span class="line">有时有散列冲突（hash collision）,有对应的解决方法，比如向后沿找空位放或者链表串起来等</span><br><span class="line">散列表太满的话会再散列（rehashed）</span><br><span class="line">如果元素的散列码发生变化，则位置可能也会改变</span><br><span class="line">散列的递归</span><br><span class="line"></span><br><span class="line">树集：TreeSet，集Set接口</span><br><span class="line">树集是一个有序集合（Sorted Collection）,红黑树（red-black tree）</span><br><span class="line">每次添加元素时，都会添加到正确的结点上，这样迭代器访问时是按照排好序的顺序访问元素</span><br><span class="line">如果不需要数据排序，不建议使用</span><br><span class="line">排序要比散列困难的多</span><br><span class="line">NavigableSet，增加了反向遍历和定位元素的方法</span><br><span class="line"></span><br><span class="line">队列和双端队列：Deque</span><br><span class="line">ArrayDeque、LinkedList</span><br><span class="line">可动态增加队列的长度</span><br><span class="line"></span><br><span class="line">优先级队列：Priority Queue</span><br><span class="line">优先级队列采用了一个高雅数据结构，堆（Heap）</span><br><span class="line">堆是一个可以自动调整的二叉树，add和remove操作会将最小的元素移动到树根，这样不用再花费时间排序</span><br><span class="line">可以进行任务调度操作，优先级最高值也为最小1</span><br><span class="line">与TreeSet不同，PriorityQueue是根据优先级排序</span><br><span class="line"></span><br><span class="line">映射表：Map</span><br><span class="line">HashMap，TreeMap</span><br><span class="line">散列映射表对键进行散列，</span><br><span class="line">树映射表用键的整体顺序进行排序，在组织成搜索树</span><br><span class="line">散列和比较函数只能用于键，其关联的值不用于散列和比较</span><br><span class="line">与集Set一样，如果不需要排序则散列</span><br><span class="line">键值（key）必须是唯一的</span><br><span class="line"></span><br><span class="line">专用集和映射表类</span><br><span class="line">弱散列映射表WeakHashMap：删除表中一些无用的值</span><br><span class="line">链接散列集LinkedHashSet和链接映射表LinkedHashMap：表面是随机排列的，实际会记住插入的顺序</span><br><span class="line">枚举集EnumSet和映射表EnumMap：位序列</span><br><span class="line">标识散列映射表IdentityHashMap：根据内存地址计算散列码</span><br><span class="line"></span><br><span class="line">集合框架：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">集合和数组之间的转化toArray()</span><br><span class="line"></span><br><span class="line">算法：排序和查找</span><br><span class="line">Collections类中的sort方法，shuffle方法，Collections是一个包装类</span><br><span class="line">将所有元素转入一个数组，然后运用归并排序的一个变体进行数组排序，好了后在复制回去</span><br><span class="line">归并排序比快速排序慢一点但是稳定</span><br><span class="line">排序方法</span><br><span class="line">查找方法</span><br><span class="line"></span><br><span class="line">遗留的集合</span><br><span class="line">HashTable和子类Properties：和HashMap类似，区别是HashTable是同步的，另一个是不同步的</span><br><span class="line">Vector和子类Stack,Bitset</span><br><span class="line">Enumeration：hasMoreElements和nextElement与Iterator的hasNext、next类似</span><br><span class="line">属性映射表（property map）</span><br><span class="line">位集BitSet：位序列，更类似与位向量或者位数组</span><br><span class="line">栈Stack</span><br></pre></td></tr></table></figure>

<h3 id="第十四章-多线程"><a href="#第十四章-多线程" class="headerlink" title="第十四章 多线程"></a>第十四章 多线程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line">多任务（multitasking），在同一时刻运行多个程序的能力。</span><br><span class="line">每一个任务可以称为线程（Thread），多线程程序（multithreaded）。</span><br><span class="line">多进程和多线程：每一个进程拥有一整套变量，而线程是共享数据。</span><br><span class="line">共享变量使得线程之间通信比进程之间更有效。</span><br><span class="line">线程是轻量级的进程，启动、撤销一个线程比启动新进程容易少开销。</span><br><span class="line">14.1 什么是线程</span><br><span class="line">线程的sleep方法可能会抛出InterruptedException异常。当这个线程在sleep时，发出中断（Interrupt）请求。</span><br><span class="line">线程使得程序能够执行多个任务，对短暂的任务可以使用线程，对耗时的复杂项目需要精心设计。</span><br><span class="line">Runnable接口：</span><br><span class="line">public interface Runnable&#123;</span><br><span class="line">void run();</span><br><span class="line">&#125;</span><br><span class="line">由Runnable创建一个Thread对象：</span><br><span class="line">Thread t&#x3D;new Thread(t);</span><br><span class="line">t.start();&#x2F;&#x2F;创建一个新的线程</span><br><span class="line">t.run();&#x2F;&#x2F;执行一个已有的线程</span><br><span class="line">但是为每一个任务创建一个独立的线程付出代价也不小，可以使用线程池。</span><br><span class="line">14.2 中断线程</span><br><span class="line">inerrupt()使用前isInterrupted()。</span><br><span class="line">14.3 线程状态</span><br><span class="line">New（新创建），Runnable（可运行，考虑优先级），Blocked（被阻塞），Waiting（等待），Time Waiting（计时等待），Terminated（被终止）。</span><br><span class="line">一个在运行状态（State）的线程可能是正在Running也可能是没有Running。</span><br><span class="line"></span><br><span class="line">14.4 线程属性</span><br><span class="line">线程优先级，守护线程，线程组，处理未捕获异常的处理器。</span><br><span class="line">线程优先级</span><br><span class="line">可以使用setPriority设置优先级，但是Java的优先级是高度依赖系统的，即通过虚拟机映射到系统中的优先级，但不同操作系统中优先级不一。进程的优先级需要谨慎使用，比如使用不当，低优先级进程会“饿死”状态。</span><br><span class="line">守护线程（daemon thread）</span><br><span class="line">为其他线程提供服务，比如计时线程，定时地发送信号给其他线程或者清空过时的高速缓存项的线程。</span><br><span class="line">未捕获异常处理器</span><br><span class="line">Thread.UncaughtExceptionHandler，线程的run并不能抛出任何已检查的错误，但是这些异常会导致线程的终止。可以用线程集合ThreadGroup，还有线程组。</span><br><span class="line">14.5 同步</span><br><span class="line">多个线程同时访问共享数据，竞争条件（race condition）。</span><br><span class="line">比如银行的转账系统。</span><br><span class="line">两种机制防止并发访问的干扰：synchronized关键字，和ReentrantLock类。</span><br><span class="line">A 锁对象：</span><br><span class="line">myLock.lock();&#x2F;&#x2F;进入锁状态</span><br><span class="line">try&#123;</span><br><span class="line">critical section</span><br><span class="line">&#125;finally&#123;&#x2F;&#x2F;确保即使程序异常也能执行finally</span><br><span class="line">myLock.unlock();&#x2F;&#x2F;解除锁</span><br><span class="line">&#125;</span><br><span class="line">锁是可以重入的，线程可以反复获得已经持有的锁，保持一个持有计数(hold count)来跟踪对lock方法的嵌套调用。线程每一次Lock()后必然调用Unlock()方法。所以，基于这一特性，被一个锁保护的代码可以调用另一个使用相同的锁的方法。留心临界区的代码。</span><br><span class="line">条件对象</span><br><span class="line">条件对象（条件变量,conditional variable）</span><br><span class="line">程序进入临界区，但是发现在满足一定条件后才执行。</span><br><span class="line">比如：</span><br><span class="line">if(a&gt;b)&#123;</span><br><span class="line">&#x2F;&#x2F;线程可能在判断完a&gt;b后满足条件,，但在执行do sth时，线程时间到，被暂停，再次得到运行时间时，a&gt;b可能已经被其他相关线程改变，而不满足，再do sth可能就有问题。比如订票系统。</span><br><span class="line">do sth</span><br><span class="line">&#125;</span><br><span class="line">可以使用锁来解决这个问题（在if前加锁），但是如果账户中没有足够的钱，此时程序通过判断后执行等待用户存钱的线程使得余额增加，但是花钱的线程却得到了线程锁，也就意味着别的相关线程无法执行，就一直卡在这。</span><br><span class="line">此时就可以使用条件变量来使得花钱线程进入阻塞状态并放弃锁，这样存钱线程可以执行。await方法可以等待条件，但并不自动恢复执行。应当再在其他线程使用signAll来激活因为同一原因而阻塞等待的线程。从而从await()处调用返回。，从阻塞的地方继续执行。当然条件可能依然不满足，signAll知识通知而已，具体需要各个线程自行判断。</span><br><span class="line">while(!(ok to process))&#123;</span><br><span class="line">condition.await();</span><br><span class="line">&#125;</span><br><span class="line">如果没有其他线程来调用signAll那么这就会产生死锁(deadlock)现象。</span><br><span class="line">同步互锁虽然解决了并发读取数据的冲突，但是速度肯定降了下来。</span><br><span class="line">B synchronized关键字</span><br><span class="line">总结Lock和Condition：</span><br><span class="line">锁用来保护代码片段，保证任何时刻只用一个线程在运行被保护的代码。</span><br><span class="line">锁可以管理试图进入被保护代码段的线程。</span><br><span class="line">锁可以拥有一个或多个相关的条件对象。</span><br><span class="line">每个条件对象管理那些已经进入被保护的代码段但还不能运行的线程</span><br><span class="line">Lock和Condition的控制是高度的，但是大多数情况并不需要如此严格。</span><br><span class="line">每个对象内部都有一个内部锁，如果使用synchronized关键字声明，那么对象锁将保护整个方法。</span><br><span class="line">public synchronized void method()&#123;&#125;&#x2F;&#x2F;隐式锁</span><br><span class="line">等价于</span><br><span class="line">public void method()&#123;&#x2F;&#x2F;显示锁</span><br><span class="line">this.intrinsicLock.lock();&#x2F;&#x2F;进入锁状态</span><br><span class="line">try&#123;</span><br><span class="line">critical section</span><br><span class="line">&#125;finally&#123;&#x2F;&#x2F;确保即使程序异常也能执行finally</span><br><span class="line">this.intrinsicLock.unlock();&#x2F;&#x2F;解除锁</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">内部锁简单够用，但是有局限：</span><br><span class="line">不能中断一个正在试图获得锁的线程。</span><br><span class="line">试图获得锁时不能设定超时。</span><br><span class="line">每个锁只有单一的条件，可能是不够的。</span><br><span class="line"></span><br><span class="line">具体是用这两种方法中的哪一种：</span><br><span class="line">这两种方法可以都不使用，使用阻塞对列来同步完成一个共同任务的线程。</span><br><span class="line">减少代码编写量可以使用synchronized关键字，简单够用。</span><br><span class="line">如果特别需要Lock&#x2F;Condition方式再使用</span><br><span class="line"></span><br><span class="line">同步阻塞</span><br><span class="line">synchronized(obj)&#123;</span><br><span class="line">critical section</span><br><span class="line">&#125;</span><br><span class="line">监视器概念</span><br><span class="line">锁和条件是线程同步的强大工具，但严格的讲，它们不是面对对象的。</span><br><span class="line">那么，可以不添加锁来保证安全性吗，那就是监视器（monitor）</span><br><span class="line">监视器是只包含私有域的类</span><br><span class="line">每个监视器类的对象有一个相关的锁。</span><br><span class="line">使用这种锁使得所有的方法都进行加锁，加锁是在方法开始之前自动获得，而方法返回时自动释放。域是私有的，所以又能确保只有一个线程能同时访问数据进行操作。</span><br><span class="line">Volatile域</span><br><span class="line">Java内存模型和线程规范。</span><br><span class="line">volatile关键字为实例域的同步访问提供了一种免锁机制。即如果声明一个域为volatile，那么编译器和虚拟机就会知道该域是被另一个线程并发更新的。</span><br><span class="line">使用synchronized可以使得保持同步，但方法也可能阻塞，再加上Condition。</span><br><span class="line">但是，如果是这样：</span><br><span class="line">public boolean isOk;</span><br><span class="line">public synchronized boolean isOk() &#123; return isOk; &#125;</span><br><span class="line">public synchronized void setOk() &#123; this.isOk&#x3D;true; &#125;</span><br><span class="line">不如这样：</span><br><span class="line">public volatile boolean isOk;</span><br><span class="line">public boolean isOk() &#123; return isOk; &#125;</span><br><span class="line">public void setOk() &#123; this.isOk&#x3D;true; &#125;</span><br><span class="line">volatile不能保证原子性。</span><br><span class="line">例如：public void flipDone() &#123; done&#x3D;!done; &#125;&#x2F;&#x2F;不是原子的，所以不能保证是能够翻转域中的值。</span><br><span class="line">final变量</span><br><span class="line">锁和volatile可以确保安全的读取一个域。</span><br><span class="line">还有一种方法是域被声明为final时可以保障。</span><br><span class="line">原子性</span><br><span class="line">java.util.concurrent.atomic包中有很多高效的机器级指令来确定不操作的原子性。</span><br><span class="line">原子性是指要么完整的一次性做完，要么就安全回滚到起点。</span><br><span class="line">死锁</span><br><span class="line">账户A:200 账户B:300</span><br><span class="line">线程1：从A转500到B</span><br><span class="line">线程2：从B转400到A</span><br><span class="line">这两个线程都阻塞了，余额均不足。这就是互锁。</span><br><span class="line">如果在运行中遇到死锁，在Java中目前没有什么解决方法，只能设计时避免。</span><br><span class="line">线程的局部变量</span><br><span class="line">SimpleDateFormat线程并不是安全的，因为如果两个线程同时调用同一个SimpleDateFormat的静态变量dateFormat的format方法时结果可能是混乱的。dateFormat的内部数据结构可能会因为并发处理而混乱。当然解决方法是每个线程一个单独的SimpleDateFormat对象，不过确实浪费。</span><br><span class="line">ThreadLocal&lt;&gt; initalValue()</span><br><span class="line">锁测试和超时</span><br><span class="line">tryLock()方法可以试图申请一个锁，成功则返回true，不成功再等待，超时后返回false。</span><br><span class="line">tryLock()在方法的等待时间时如果被中断会抛出InterruptedException并退出，这个可以反过来打破死锁，比如向死锁线程发送中断信号。</span><br><span class="line">同理await也有超时等待设置。特别的awaitUninterruptibly可以对InterruptedException不予理会，继续等待。</span><br><span class="line">读&#x2F;写锁</span><br><span class="line">ReentrantReadWriteLock类，readLock()和writeLock()。</span><br><span class="line">适用于读的多写的少，或者写的多读的少情况。</span><br><span class="line">stop，suspend阻塞，resume天生不安全，容易导致死锁和意外情况。</span><br><span class="line">安全的挂起线程需要引入boolean变量来使得线程在suspend挂起的时候没有影响到其他线程需要对象的地方。</span><br><span class="line">14.6 阻塞队列</span><br><span class="line">上节内容是Java底层实现并发程序设计的技术。但是，正常使用中应当考虑阻塞队列。</span><br><span class="line">比如根关键字查找某目录下包含子目录的文件及文件内容。</span><br><span class="line">生产者线程负责枚举所有的文件，并添加到队列中去。</span><br><span class="line">搜索线程负责取出队列的东东，然后匹配判断。</span><br><span class="line">队列数据结构可以作为一种同步机制，但是显式的线程同步也是需要的。</span><br><span class="line">14.7 线程安全的集合</span><br><span class="line">映射表（HashMap），有序表（SkipListMap，SkipListSet），队列（LinkedQueue）。</span><br><span class="line">这些集合往往采用复杂的算法，来确保并发访问的安全性。</span><br><span class="line">写数组的拷贝CopyOnWriteArrayList，和CopyOnWriteArraySet。</span><br><span class="line">较早的线程安全集合Vector和HashTable，以及后来的ArrayLIst和HashMap，不过他们并不是安全的，可以通过同步包装器（synchronization wrapper）来加锁等确保安全。</span><br><span class="line">不过再此建议使用synchronizedList和synchronizedMap，而不是自己手动封装。</span><br><span class="line">比如：List&lt;E&gt; synchArrayList&#x3D;Collections.synchronizedList(new ArraryList&lt;E&gt;());</span><br><span class="line">   Map&lt;K,V&gt; synchHashMap&#x3D;Collections.synchronizedMap(new HashMap&lt;K,V&gt;());</span><br><span class="line">14.8 Callbale和Future</span><br><span class="line">Runnable封装一个异步运行的任务，是一个没有参数和返回值的异步方法。</span><br><span class="line">而Callable是有返回值和参数的，只有一个方法call()</span><br><span class="line">public interface Callable&lt;V&gt;&#123;</span><br><span class="line">V call() throws Exception;</span><br><span class="line">&#125;</span><br><span class="line">类型参数是返回值的类型。</span><br><span class="line">Future保存异步计算的结果，Future可以将计算结果保存好，可以稍后获取。</span><br><span class="line">可以把结果放在ArrayList里，比如ArrayList&lt;Future&lt;Integer&gt;&gt;</span><br><span class="line">14.9 执行器</span><br><span class="line">线程池（thread pool）用来解决程序中大量生命期比较短的线程。当run方法结束后，线程不会死亡，而是再等待为下一个请求服务。同时创建大量的线程也大大降低性能，甚至使得虚拟机崩溃。所以一个固定数目的线程池是有必要的。</span><br><span class="line">执行器（Executor）类用于构建线程池。</span><br><span class="line">1调用newCachedThreadPool,newFixedThreadPool,newSingleThreadPool等静态方法</span><br><span class="line">2调用submit提交Runnable或Callable对象</span><br><span class="line">3如果要取消一个task，或提交Callable对象，需要保存好返回的Future对象，因为线程池别的进程也会使用。</span><br><span class="line">4shutdown,shutdownNow</span><br><span class="line">预定执行（scheduledExecutorService）或重复执行。允许线程池机制的Timer的泛化。</span><br><span class="line">控制任务组invokeAny。比如因式分解求解RSA，可以一次提交很多任务，只要有一个得到答案，其他的可以结束。</span><br><span class="line">Fork-Join框架</span><br><span class="line">用以将一个大问题划分为小部分，同时计算。RecursiveTask</span><br><span class="line">在后台，fork-jion框架使用了有效的智能方式来保持线程的工作负载。称为工作密取(work stealing)。每个工作线程都有一个双端队列(deque)来完成任务。</span><br><span class="line">比如在100000000个随机0-1的小数中，统计符合要求的数字和，比如x&gt;0.5。就可以采fork-join框架：在compute方法内，invokeAll接收很多小任务后阻塞，知道所有的小任务完成后再返回，而join方法获得各个小任务的返回值。</span><br><span class="line">同步器（java.util.concurrent）</span><br><span class="line">管理相互合作的线程集。</span><br><span class="line">信号量，倒计时门栓（CountDownLatch，下一个任务等待当前的任务计数减为0再运行），障栅（barrier，将运行进度不一致的线程统一起来，到某个阶段都同步起来再继续执行），交换器（Exchanger，共用数据缓冲区，一个写，一个读，完事再相互交换），同步队列（synchronousQueue，数据沿着一个方向传递，一个只负责put生产，另一个就一直take消费，不相互交换）</span><br><span class="line">14.11 线程与Swing</span><br><span class="line">在界面中使用线程是为了提高响应的性能。当程序再做某一个耗时的任务时，应当启动另一个线程来继续与用户接口交互。Swing并不是线程安全的，也就是说，多线程会导致界面崩溃，而程序的逻辑功能可能继续运行。Swing不使用同步机制的原因在于，同步需要大量的时间，降低速度，另一方面，同步机制比较容易搞混，造成死锁。</span><br><span class="line">运行耗时的任务</span><br><span class="line">如果线程任务耗时，那把它通过分配任务线程扔到一个独立的线程吧</span><br><span class="line">除了事件分配线程，其他的线程与界面无关，尽量分开他们。单一线程规则（single-thread rule）</span><br><span class="line">事件分配线程不要进行IO操作等耗时或者资源操作，很可能会卡死，也不要调用sleep()方法，如果需要等待指定的时间，建议使用定时器事件。</span><br><span class="line">这两条规则看起来彼此冲突，比如进行一个下载操作，启动下载线程，同时在界面上更行进度条。但是下载进程不能接触Swing组件。为此，可以将界面更新操作放在invokeLater和invokeAndWait里。</span><br><span class="line">EventQueue.invokeLater(new Runnable()&#123;</span><br><span class="line">public void run()&#123;</span><br><span class="line">label.setText(percentage+&quot;ok&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">invokeLater会立即返回继续执行原来程序的接下来的部分，而run的方法会异步执行。例子读取长文件文本内容。</span><br><span class="line">单一线程机制</span><br><span class="line">main就是一个单一的线程。在Swing程序中，main的生命周期比较短暂，基本就是构建用户界面后退出，接下来由事件分配处理线程来接管。Swing中大部分方法是不安全的，只有很少但很有用的是安全的。</span><br><span class="line">JTextComponent.setText</span><br><span class="line">JTextArea.insert</span><br><span class="line">JTextArea.append</span><br><span class="line">JTextArea.replaceRange</span><br><span class="line">JComponent.repaint</span><br><span class="line">JComponent.revalidate</span><br></pre></td></tr></table></figure>

<blockquote>
<p>卷I - 终</p>
</blockquote>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E9%98%85%E8%AF%BB/" rel="tag"># 阅读</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2016/06/04/book-sjjgysfjdwtjx/" rel="prev" title="数据结构与算法经典问题解析">
      <i class="fa fa-chevron-left"></i> 数据结构与算法经典问题解析
    </a></div>
      <div class="post-nav-item">
    <a href="/2016/07/03/use-vbox-on-linux/" rel="next" title="在Ubuntu服务器中安装和配置VirtualBox">
      在Ubuntu服务器中安装和配置VirtualBox <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E2%80%93%E5%8D%B7I"><span class="nav-number">1.</span> <span class="nav-text">Java核心技术–卷I</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%AF%8F%E7%AB%A0%E5%B0%8F%E7%BB%93"><span class="nav-number">2.</span> <span class="nav-text">每章小结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-Java%E7%A8%8B%E5%BA%A6%E8%AE%BE%E8%AE%A1%E6%A6%82%E8%BF%B0"><span class="nav-number">2.1.</span> <span class="nav-text">第一章 Java程度设计概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-Java%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%8E%AF%E5%A2%83"><span class="nav-number">2.2.</span> <span class="nav-text">第二章 Java程序设计环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-Java%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%BB%93%E6%9E%84"><span class="nav-number">2.3.</span> <span class="nav-text">第三章 Java的基本程序设计结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB"><span class="nav-number">2.4.</span> <span class="nav-text">第四章 对象与类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E7%BB%A7%E6%89%BF"><span class="nav-number">2.5.</span> <span class="nav-text">第五章 继承</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%86%85%E9%83%A8%E7%B1%BB"><span class="nav-number">2.6.</span> <span class="nav-text">第六章 接口与内部类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0%E5%88%B0%E7%AC%AC%E4%B9%9D%E7%AB%A0-GUI%E9%83%A8%E5%88%86"><span class="nav-number">2.7.</span> <span class="nav-text">第七章到第九章 GUI部分</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E9%83%A8%E7%BD%B2%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%92%8Capplet"><span class="nav-number">2.8.</span> <span class="nav-text">第十章 部署应用程序和applet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%BC%82%E5%B8%B8%E3%80%81%E6%96%AD%E8%A8%80%E3%80%81%E6%97%A5%E5%BF%97%E5%92%8C%E8%B0%83%E8%AF%95"><span class="nav-number">2.9.</span> <span class="nav-text">第十一章 异常、断言、日志和调试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="nav-number">2.10.</span> <span class="nav-text">第十二章 泛型程序设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E9%9B%86%E5%90%88"><span class="nav-number">2.11.</span> <span class="nav-text">第十三章 集合</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="nav-number">2.12.</span> <span class="nav-text">第十四章 多线程</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="码农小钱"
      src="/uploads/custom-avatar.jpg">
  <p class="site-author-name" itemprop="name">码农小钱</p>
  <div class="site-description" itemprop="description">// todo sth.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">75</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chaingit" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;chaingit" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:chainz@foxmail.com" title="E-Mail → mailto:chainz@foxmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        
  <div class="beian"><a href="http://www.beian.miit.gov.cn/" rel="noopener" target="_blank">苏ICP备16052713号-1 </a>
  </div>

<div class="copyright">
  
  &copy; 2016 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">码农小钱</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>

<script src="/js/bookmark.js"></script>




  




  
<script src="/js/local-search.js"></script>













  

  

</body>
</html>
